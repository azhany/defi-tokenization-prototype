package eth

import (
	"math/big"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/ethclient"
)

type EthClient struct {
	Client      *ethclient.Client
	Auth        *bind.TransactOpts
	StableToken *StableToken
	LendingPool *LendingPool
	NFTContract *CollateralNFT
}

func NewEthClient(infuraKey, keystorePath, passphrase, tokenAddr, poolAddr, nftAddr string) (*EthClient, error) {
	client, err := ethclient.Dial("https://goerli.infura.io/v3/" + infuraKey)
	if err != nil {
		return nil, err
	}

	auth, err := bind.NewTransactorWithChainID(keystorePath, passphrase, big.NewInt(5)) // Goerli chainID=5
	if err != nil {
		return nil, err
	}

	stableToken, err := NewStableToken(common.HexToAddress(tokenAddr), client)
	if err != nil {
		return nil, err
	}

	lendingPool, err := NewLendingPool(common.HexToAddress(poolAddr), client)
	if err != nil {
		return nil, err
	}

	nftContract, err := NewCollateralNFT(common.HexToAddress(nftAddr), client)
	if err != nil {
		return nil, err
	}

	return &EthClient{
		Client:      client,
		Auth:        auth,
		StableToken: stableToken,
		LendingPool: lendingPool,
		NFTContract: nftContract,
	}, nil
}

// Note: Contract interfaces will be generated by abigen tool
type StableToken interface {
	Mint(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error)
	BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error)
}

type LendingPool interface {
	Deposit(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error)
	Withdraw(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error)
	GetUserBalance(opts *bind.CallOpts, account common.Address) (*big.Int, error)
}

type CollateralNFT interface {
	Mint(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error)
	TokensOfOwner(opts *bind.CallOpts, owner common.Address) ([]*big.Int, error)
}
