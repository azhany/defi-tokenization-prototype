package eth

import (
	"context"
	"fmt"
	"math/big"
	"os"
	"sync"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/ethclient"

	"defi-tokenization-prototype/internal/eth/contracts"
	"defi-tokenization-prototype/internal/eth/mock"
)

// EthClient wraps the Ethereum client and contract instances
type EthClient struct {
	Client      *ethclient.Client
	Auth        *bind.TransactOpts
	StableToken contracts.StableToken
	LendingPool contracts.LendingPool
	NFTContract contracts.CollateralNFT
}

// Transaction represents a generic transaction to be processed
type Transaction struct {
	Type   string      // Type of transaction (mint, deposit, withdraw, etc)
	Amount *big.Int    // Amount involved in the transaction
	Data   interface{} // Additional data if needed
}

// Note: Contract interfaces will be generated by abigen tool
type StableToken interface {
	Mint(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error)
	BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error)
}

type LendingPool interface {
	Deposit(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error)
	Withdraw(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error)
	GetUserBalance(opts *bind.CallOpts, account common.Address) (*big.Int, error)
}

type CollateralNFT interface {
	Mint(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error)
	TokensOfOwner(opts *bind.CallOpts, owner common.Address) ([]*big.Int, error)
}

func NewEthClient(infuraKey, keystorePath, passphrase, tokenAddr, poolAddr, nftAddr string) (*EthClient, error) {
	client, err := ethclient.Dial("https://goerli.infura.io/v3/" + infuraKey)
	if err != nil {
		return nil, err
	}

	// Read keystore file
	keystoreFile, err := os.Open(keystorePath)
	if err != nil {
		return nil, fmt.Errorf("failed to open keystore file: %v", err)
	}
	defer keystoreFile.Close()

	auth, err := bind.NewTransactorWithChainID(keystoreFile, passphrase, big.NewInt(5)) // Goerli chainID=5
	if err != nil {
		return nil, err
	}

	var wg sync.WaitGroup
	var stableToken StableToken
	var lendingPool LendingPool
	var nftContract CollateralNFT
	var stableErr, lendingErr, nftErr error

	wg.Add(3)

	// Initialize contracts in parallel
	go func() {
		defer wg.Done()
		var err error
		// Using mock implementations for now
		stableToken, err = mock.CreateMockStableToken(common.HexToAddress(tokenAddr), client)
		if err != nil {
			stableErr = fmt.Errorf("failed to initialize stable token: %v", err)
		}
	}()

	go func() {
		defer wg.Done()
		var err error
		// Using mock implementations for now
		lendingPool, err = mock.CreateMockLendingPool(common.HexToAddress(poolAddr), client)
		if err != nil {
			lendingErr = fmt.Errorf("failed to initialize lending pool: %v", err)
		}
	}()

	go func() {
		defer wg.Done()
		var err error
		// Using mock implementations for now
		nftContract, err = mock.CreateMockCollateralNFT(common.HexToAddress(nftAddr), client)
		if err != nil {
			nftErr = fmt.Errorf("failed to initialize NFT contract: %v", err)
		}
	}()

	wg.Wait()

	// Check for errors
	if stableErr != nil {
		return nil, stableErr
	}
	if lendingErr != nil {
		return nil, lendingErr
	}
	if nftErr != nil {
		return nil, nftErr
	}

	return &EthClient{
		Client:      client,
		Auth:        auth,
		StableToken: stableToken,
		LendingPool: lendingPool,
		NFTContract: nftContract,
	}, nil
}

// BatchProcessTransactions processes multiple transactions in parallel
func (c *EthClient) BatchProcessTransactions(txs []Transaction) error {
	var wg sync.WaitGroup
	errChan := make(chan error, len(txs))

	for _, tx := range txs {
		wg.Add(1)
		go func(tx Transaction) {
			defer wg.Done()
			if err := c.processTx(tx); err != nil {
				errChan <- fmt.Errorf("%s transaction failed: %v", tx.Type, err)
			}
		}(tx)
	}

	wg.Wait()
	close(errChan)

	var errors []error
	for err := range errChan {
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return fmt.Errorf("batch processing errors: %v", errors)
	}
	return nil
}

// processTx processes a single transaction based on its type
func (c *EthClient) processTx(tx Transaction) error {
	var err error
	var transaction *types.Transaction

	switch tx.Type {
	case "mint":
		transaction, err = c.StableToken.Mint(c.Auth, tx.Amount)
	case "deposit":
		transaction, err = c.LendingPool.Deposit(c.Auth, tx.Amount)
	case "withdraw":
		transaction, err = c.LendingPool.Withdraw(c.Auth, tx.Amount)
	case "mintNFT":
		transaction, err = c.NFTContract.Mint(c.Auth, tx.Amount)
	default:
		return fmt.Errorf("unknown transaction type: %s", tx.Type)
	}

	if err != nil {
		return err
	}

	ctx := context.Background()
	_, err = bind.WaitMined(ctx, c.Client, transaction)
	return err
}

// BulkMintNFTs mints multiple NFTs in parallel
func (c *EthClient) BulkMintNFTs(amounts []*big.Int) error {
	var wg sync.WaitGroup
	errChan := make(chan error, len(amounts))

	for _, amount := range amounts {
		wg.Add(1)
		go func(amt *big.Int) {
			defer wg.Done()
			tx, err := c.NFTContract.Mint(c.Auth, amt)
			if err != nil {
				errChan <- fmt.Errorf("NFT mint failed: %v", err)
				return
			}

			ctx := context.Background()
			_, err = bind.WaitMined(ctx, c.Client, tx)
			if err != nil {
				errChan <- fmt.Errorf("failed waiting for NFT mint to be mined: %v", err)
			}
		}(amount)
	}

	wg.Wait()
	close(errChan)

	var errors []error
	for err := range errChan {
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return fmt.Errorf("bulk mint errors: %v", errors)
	}
	return nil
}
